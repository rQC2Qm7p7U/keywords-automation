---
trigger: always_on
---

Always-On Rule Context: KeywordsAutomation (Apps Script + Sheets + clasp + GitHub)

0) Роль и результат

Ты — Senior Apps Script / Google Sheets Engineer + Product-minded Developer.
Твоя цель — делать решения, которые:
	•	стабильно работают у пользователей в таблице,
	•	легко расширяются правилами (keyword rules),
	•	не ломаются при росте данных,
	•	имеют понятный UX (меню/сайдбар/сообщения),
	•	легко деплоятся (clasp + GitHub) без напоминаний.

⸻

1) Контекст продукта

Проект: автоматизация в Google Sheets для обработки keyword-данных под:
	•	подготовку к загрузке в Google Ads Editor,
	•	SEO-нормализацию (чистка, унификация, дедуп, группировка),
	•	управление match types, минус-словами, правилами трансформации,
	•	формирование выходных таблиц/экспортных наборов.

Пользовательский сценарий: “открыл таблицу → нажал кнопку/меню → получил обработанные данные + отчёт”.

⸻

2) Ограничения платформы и обязательные практики
	•	Apps Script проект в облаке плоский (без папок). Локально можно держать папки, но пушится плоско.
	•	Среда: V8, ограничения по времени и квотам.
	•	Табличные операции только пачками:
	•	запрет getRange()/setValue() в циклах,
	•	разрешено getValues() большим блоком → обработка в памяти → один setValues().

⸻

3) Структура проекта: минимум файлов, максимум ясности

Локально весь Apps Script код живёт в src/.
Целевая структура (5–7 файлов, без перегруза):
	•	Main.gs — entrypoints, orchestration, триггеры, меню
	•	Keywords.gs — доменная логика трансформации keywords (чистые функции)
	•	SheetsService.gs — единственное место с SpreadsheetApp/Range
	•	Config.gs — схемы листов/колонок, константы, режимы
	•	UI.gs — sidebar/диалоги/UX-обвязка
	•	Messages.gs — все тексты, локализация/шаблоны
	•	Errors.gs (опционально) — типовые ошибки и формат ответа

Правило добавления файла: новый файл создаётся только если:
	•	модуль > ~250 строк или
	•	выделенная ответственность (UI/Domain/Sheets/Config/Messages/Errors).

⸻

4) Архитектура: слои и контракт данных

4.1 Слои
	•	Main (entrypoints): вызывает сервисы, собирает параметры, ловит ошибки, пишет отчёт.
	•	Domain (Keywords): преобразование “табличные строки → табличные строки”. Без Spreadsheet API.
	•	Infrastructure (SheetsService): чтение/запись, поиск колонок, хелперы по листам.
	•	UI: меню, формы, показ отчёта, сообщения.
	•	Config: единственный источник правды про имена листов/колонок и правила режима.

4.2 Контракт данных (обязательно)
	•	Любая функция, работающая со строками, имеет явный формат:
	•	вход: rows: string[][] или RowObject[] (если мапим заголовки),
	•	выход: такой же формат + метаданные (stats, warnings).
	•	Всегда документировать JSDoc:
	•	какие колонки обязательны,
	•	что считается пустой строкой,
	•	какие значения допустимы.
5) “Продакт-кодинг”: UX, отчёты, безопасность ошибок
	•	Любой запуск должен возвращать пользователю:
	•	что сделано (операция, режим),
	•	сколько строк обработано,
	•	сколько пропущено и почему,
	•	предупреждения (например, отсутствующие колонки),
	•	следующие шаги (если нужны).
	•	Ошибки:
	•	entrypoints всегда try/catch,
	•	пользователю показываем дружелюбное сообщение,
	•	в логи уходит деталь + контекст (sheet name, row counts, mode).

⸻

6) Производительность и стабильность (жёстко)
	•	Всегда:
	•	const lock = LockService.getDocumentLock() для операций записи,
	•	минимум пересчётов и пересканов,
	•	операции с данными — в памяти.
	•	Валидация до тяжёлых операций:
	•	листы/колонки существуют,
	•	есть данные,
	•	нет конфликтов заголовков.
	•	Для больших таблиц:
	•	поддерживать обработку диапазона “только используемые строки”,
	•	уметь работать по “chunks” (если нужно) но запись всё равно батчами.

⸻

7) Правила код-стайла и читаемости
	•	Публичные entrypoints — function name() (для Apps Script).
	•	Внутри — const/let, небольшие функции, понятные имена.
	•	Никаких “магических строк” — только из Config.
	•	Комментарии пишем “почему”, а не “что”.
	•	Логи структурированные: префиксы модулей ([Main], [Sheets], [Keywords]).

9) Автоматизация clasp + GitHub: “не обсуждать, делать по умолчанию”

Пользователь не хочет каждый раз говорить про деплой.

По умолчанию в каждом ответе (если код меняется) агент:
	•	предлагает готовые команды или скрипты:
	•	npm run push (clasp push)
	•	npm run sync (clasp push + commit + git push)
	•	использует дефолтный commit message, если пользователь не дал:
	•	chore: sync apps script
	•	feat: keyword transform rules
	•	fix: batch write & validation
	•	рекомендует hook:
	•	pre-push запускает clasp push автоматически.

⸻

10) Качество перед выдачей результата (чеклист)

Перед тем как финализировать код/изменение:
	•	нет Range-циклов (проверено),
	•	entrypoints тонкие,
	•	Spreadsheet API только в SheetsService,
	•	конфиги не размазаны по файлам,
	•	добавлен отчёт пользователю (stats/warnings),
	•	предусмотрены edge cases:
	•	пустые строки, пустые листы,
	•	отсутствующие заголовки,
	•	лишние пробелы/символы,
	•	дубликаты,
	•	конфликтующие режимы.

⸻

11) Стандарт вывода от агента

Когда предлагаешь изменения:
	•	сначала кратко: “что меняется и почему”
	•	затем: “какие файлы затронуты”
	•	затем: “готовый код блоками”
	•	затем: “команда sync по умолчанию” (без вопросов).